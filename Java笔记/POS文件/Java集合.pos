{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"2ff359b2d1f52503","children":[{"parent":"fedcd0c5fc6fe116","children":[],"id":"3af998e40444b719","title":"boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象，相同new String（abc）是true&nbsp; 相同的class是fasle，因为里面的equals是==，向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().使得对应的是同一个"},{"parent":"fedcd0c5fc6fe116","children":[],"id":"4f90e0b2d47b2bd4","title":"数组 ---&gt;集合（list）:调用Arrays类的静态方法asList() 注意&nbsp; asList内部要使用类，不要用基本数据类型，比如new int[]{100,200}，而是使用Integer，不然可能会识别为一个object"},{"parent":"fedcd0c5fc6fe116","children":[{"parent":"0df2eb5f0f09c176","children":[],"id":"d257f4d651fde4be","title":"&nbsp;hasNext()和Next()结合来遍历 不可用Next()！=null来判断 会调整输出"},{"parent":"0df2eb5f0f09c176","children":[],"id":"8d05acc785336fc0","title":"不可以用coll.iterator().hasNext()来判断 每次都会生成一个新的iterator会始终第一个"},{"parent":"0df2eb5f0f09c176","children":[],"id":"57c0fc9766192437","title":"Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法"}],"id":"0df2eb5f0f09c176","title":"Iterator()是接口 对应于Collection的iterator方法&nbsp; 遍历集合&nbsp; Iterator iterator = coll.iterator()&nbsp;&nbsp;"},{"parent":"fedcd0c5fc6fe116","children":[],"id":"273a8ef32f8adc16","title":"foreach方法来遍历，底层代码也是使用Iterator。foreach中每个内部值是新建的，不可对原值进行修改"}],"id":"fedcd0c5fc6fe116","title":"Collection中常用方法"},{"parent":"2ff359b2d1f52503","children":[{"parent":"83d9cc275e28bbdc","children":[{"parent":"b2bb17467c9a3f70","children":[],"id":"a78ace763445f56f","title":"线程不安全 效率高&nbsp;底层使用Object[] elementData存储"},{"parent":"b2bb17467c9a3f70","children":[],"id":"4fe1d50cd2cc3721","title":"&nbsp; jdk7 ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData，也可以指定容量 扩容会扩1.5倍类似StringBuffer"},{"parent":"b2bb17467c9a3f70","children":[],"id":"0bdcb920cf7fbc56","title":"jdk8 创建为空，add了之后再创建10"},{"parent":"b2bb17467c9a3f70","children":[],"id":"496029e59dd1d1fa","title":"jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。"},{"parent":"b2bb17467c9a3f70","children":[],"id":"fbea1effb86554df","title":"问题？JDK16的源码和jdk7类似？？？？"}],"id":"b2bb17467c9a3f70","title":"ArrayList List接口主要实现类"},{"parent":"83d9cc275e28bbdc","children":[{"parent":"47f96881e6d241fb","children":[],"id":"a8481099c05f22b1","title":"对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储，和ArrayList区别在于底层"},{"parent":"47f96881e6d241fb","children":[],"id":"71941ffee034c43f","title":"LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null"}],"id":"47f96881e6d241fb","title":"LinkList&nbsp;"},{"parent":"83d9cc275e28bbdc","children":[{"parent":"300cfedb2450618b","children":[],"id":"d727b24f91940815","title":"线程安全 效率低&nbsp;底层使用Object[] elementData存储"},{"parent":"300cfedb2450618b","children":[],"id":"8ecae8b228edce88","title":"操作和ArraList类似"},{"parent":"300cfedb2450618b","children":[],"id":"20c413dcc26b50ef","title":"通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。"}],"id":"300cfedb2450618b","title":"Vector&nbsp; List接口古老实现类"}],"id":"83d9cc275e28bbdc","title":"List：元素有序、可重复的集合&nbsp; \"动态数组\"&nbsp; Collection子接口"},{"parent":"2ff359b2d1f52503","children":[{"parent":"4e45e0d80a0a2889","children":[],"id":"5b9ccfb96ed2826a","title":"1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定<br>"},{"parent":"4e45e0d80a0a2889","children":[],"id":"6d2e1054c8f20133","title":"2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。"},{"parent":"4e45e0d80a0a2889","children":[],"id":"00e0a46e5fe9a188","title":"3.要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals(),且保持一致性"},{"parent":"4e45e0d80a0a2889","children":[{"parent":"6082c7c9f23b4683","children":[],"id":"d49f0e9c29d68ea4","title":"&nbsp;Set主要实现类，线程不安全，可以存储null，底层是数组 +链表"},{"parent":"6082c7c9f23b4683","children":[{"parent":"69b8308cee9f12ec","children":[],"id":"94ffe0a9fd85801e","title":"1. 首先调用元素a所在类的hashCode()方法，计算元素a的哈希值&nbsp;"},{"parent":"69b8308cee9f12ec","children":[],"id":"cb98bbb4bb594ee3","title":"2.哈希值对应数组某个位置,对比该位置元素(或以链表形式存在的多个元素 ，hash值不同就添加"},{"parent":"69b8308cee9f12ec","children":[],"id":"1c10f4459093c2c5","title":"3.如果hash值相同，进而需要调用元素a所在类的equals()方法"}],"id":"69b8308cee9f12ec","title":"&nbsp;向HashSet中添加元素a步骤"},{"parent":"6082c7c9f23b4683","children":[{"parent":"891301040486a1d3","children":[],"id":"037a8e02d01949ff","title":"在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值，Object是返回随机数"},{"parent":"891301040486a1d3","children":[],"id":"4020c1c20f6e4383","title":"当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应相等"},{"parent":"891301040486a1d3","children":[],"id":"1ff722493428ba4c","title":"对象中用作equals() 方法比较的Field，都应该用来计算hashCode值"}],"id":"891301040486a1d3","title":"重写HashCode()方法"},{"parent":"6082c7c9f23b4683","children":[{"parent":"4b181d38b9546ffa","children":[],"id":"407cc26b12c69ad3","title":"复写equals方法的时候一般都需要同时复写hashCode方法"},{"parent":"4b181d38b9546ffa","children":[],"id":"81794fcc65a3c10d","title":"通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算"}],"id":"4b181d38b9546ffa","title":"重写equal()方法"}],"id":"6082c7c9f23b4683","title":"HashSet&nbsp;"},{"parent":"4e45e0d80a0a2889","children":[{"parent":"d27623a4fa0408a1","children":[],"id":"28ec009d74b82393","title":"作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 对于频繁的遍历操作，LinkedHashSet效率高于HashSet"},{"parent":"d27623a4fa0408a1","children":[],"id":"d9b7794bffb86ba6","title":"LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的"},{"parent":"d27623a4fa0408a1","children":[],"id":"a2d5cf32ecd8c016","title":"LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能"}],"id":"d27623a4fa0408a1","title":"LinkedHashSet&nbsp; HashSet子类&nbsp;&nbsp;"},{"parent":"4e45e0d80a0a2889","children":[{"parent":"6f07f1f0f003722b","children":[],"id":"54db4e112d240c12","title":"TreeSet中添加数据 必须是同一类"},{"parent":"6f07f1f0f003722b","children":[],"id":"f3feaf6b40fc19bb","title":"可以按照添加对象的指定属性，进行排序 红黑数存储"},{"parent":"6f07f1f0f003722b","children":[{"parent":"47204d6fac13e438","children":[],"id":"4fb288e2ae9ab544","title":"如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口"},{"parent":"47204d6fac13e438","children":[],"id":"2d2116f910099978","title":"两个对象即通过compareTo(Object obj)方法的返回值来比较大小"},{"parent":"47204d6fac13e438","children":[],"id":"a4353a0f8fb6e73f","title":"重写compareTo方法，而不是使用equals()"}],"id":"47204d6fac13e438","title":"自然排序"},{"parent":"6f07f1f0f003722b","children":[{"parent":"775fba8a9e7d4b1f","children":[],"id":"5f7ce7daac72a11a","title":"实现Comparator接口的实例作为形参传递给TreeSet的构造器，可以使用不同的比较方法"},{"parent":"775fba8a9e7d4b1f","children":[],"id":"9c23d75147b26a12","title":"重写conpare方法，自然排序是compareTo()"},{"parent":"775fba8a9e7d4b1f","children":[],"id":"41002925564548aa","title":"自然排序是在TreeSet的对象类中重写，只能用这种方法"}],"id":"775fba8a9e7d4b1f","title":"定制排序"}],"id":"6f07f1f0f003722b","title":"TreeSet&nbsp;"}],"id":"4e45e0d80a0a2889","title":"Set：元素无序、不可重复的集合"}],"id":"2ff359b2d1f52503","title":"Collection接口：单列数据，定义了存取一组对象的方法的集合&nbsp;<br>"},{"parent":"root","children":[{"parent":"183c283e5d850045","children":[],"id":"1763a135f6ead034","title":"双列数据，保存具有映射关系“key-value对”的集合"},{"parent":"183c283e5d850045","children":[{"parent":"8b4429f6f17aa1a1","children":[],"id":"7d63dcb7d4c11d6d","title":"Set keySet()：返回所有key构成的Set集合<br>"},{"parent":"8b4429f6f17aa1a1","children":[],"id":"b69038b46251d2cb","title":"Collection values()：返回所有value构成的Collection集合"},{"parent":"8b4429f6f17aa1a1","children":[],"id":"73310be78894b460","title":"Set entrySet()：返回所有key-value对构成的Set集合"}],"id":"8b4429f6f17aa1a1","title":"Map的遍历"},{"parent":"183c283e5d850045","children":[{"parent":"ec62066419aa0464","children":[],"id":"a1cdabf78692e296","title":"Map 中的key 用Set来存放，不允许重复，即同一个Map 对象所对应的类，须重写hashCode()和equals()方法（hashMap为例），value()是可重复无序，需要重写equals()"},{"parent":"ec62066419aa0464","children":[],"id":"4ddf45496c57e9ed","title":"Map中的key和value都可以是任何引用类型的数据"},{"parent":"ec62066419aa0464","children":[],"id":"c0665d103ff15c66","title":"一个键值对：key-value构成了一个Entry对象，Map中的entry:无序的、不可重复的，使用Set存储所有的entry"}],"id":"ec62066419aa0464","title":"Map中存储的key-value的特点"},{"parent":"183c283e5d850045","children":[{"parent":"730d40c2d1aab35c","children":[],"id":"d4297af48235af7e","title":"作为Map的主要实现类；线程不安全的，效率高；存储null的key和value"},{"parent":"730d40c2d1aab35c","children":[{"parent":"911a0f9ef559f096","children":[],"id":"66438e67f7e64c91","title":"调用key所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置"},{"parent":"911a0f9ef559f096","children":[],"id":"e1296c947bcd2220","title":"如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据"},{"parent":"911a0f9ef559f096","children":[],"id":"8338319e51e2c843","title":"如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals"},{"parent":"911a0f9ef559f096","children":[],"id":"dc878feb867cd545","title":"扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来"},{"parent":"911a0f9ef559f096","children":[{"parent":"779487d74a5e1c6a","children":[],"id":"ef014c0cb56905ac","title":"new HashMap():底层没有创建一个长度为16的数组 jdk 8底层的数组是：Node[],而非Entry[]"},{"parent":"779487d74a5e1c6a","children":[],"id":"a2dda88437f2fb97","title":"首次调用put()方法时，底层创建长度为16的数组"},{"parent":"779487d74a5e1c6a","children":[],"id":"625a9e6f0952e918","title":"jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树"},{"parent":"779487d74a5e1c6a","children":[],"id":"111f7df6bdaa3e49","title":"当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储（便于比较使用树 而不是链表形式）"},{"parent":"779487d74a5e1c6a","children":[],"id":"49b27b9816b6656f","title":"形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）"}],"id":"779487d74a5e1c6a","title":"&nbsp;jdk8 相较于jdk7在底层实现方面的不同"}],"id":"911a0f9ef559f096","title":"HashMap底层实现原理：JDK7"}],"id":"730d40c2d1aab35c","title":"HashMap"},{"parent":"183c283e5d850045","children":[{"parent":"32d45a4f3849bf2b","children":[],"id":"1fafcc23f9a2b785","title":"类似于LinkHashSet，遍历元素时按照添加顺序遍历"},{"parent":"32d45a4f3849bf2b","children":[],"id":"31ccbed82776dd23","title":"使用双向链表维护元素的次序，指向前一个和后一个元素，这使得元素看起来是以插入顺序保存的"},{"parent":"32d45a4f3849bf2b","children":[],"id":"f4332303580fac02","title":"对于频繁遍历操作 效率高"},{"parent":"32d45a4f3849bf2b","children":[],"id":"ea82f222bc53e5d3","title":"与LinkedHashSet类似，LinkedHashMap可以维护Map 的迭代顺序：迭代顺序与Key-Value 对的插入顺序一致"},{"parent":"32d45a4f3849bf2b","children":[],"id":"c0399ac99b0f03bc","title":"hashMap和hashTable区别"}],"id":"32d45a4f3849bf2b","title":"LinkdHashMap"},{"parent":"183c283e5d850045","children":[{"parent":"466d0cd93ee6dec3","children":[],"id":"7476453d62df43a3","title":"底层使用红黑树"},{"parent":"466d0cd93ee6dec3","children":[],"id":"e2b88f5d76180806","title":"保证按照添加的key-value对进行排序，实现排序遍历此时<br>"},{"parent":"466d0cd93ee6dec3","children":[],"id":"17423b3bb52fbc81","title":"考虑key的自然排序或定制排序 和TreeSet类似"}],"id":"466d0cd93ee6dec3","title":"TreeMap&nbsp;"},{"parent":"183c283e5d850045","children":[{"parent":"a5db3499b7c00159","children":[],"id":"9e1aa3f775c27ebe","title":"古老的实现类"},{"parent":"a5db3499b7c00159","children":[],"id":"527a60070023a430","title":"线程安全 效率低&nbsp;不能存储null的key和value"},{"parent":"a5db3499b7c00159","children":[],"id":"90c5f85a6ae0cfb7","title":"Properties:常用来处理配置文件。key和value都是String类型"}],"id":"a5db3499b7c00159","title":"Hashtable"}],"id":"183c283e5d850045","title":"Map"},{"parent":"root","children":[{"parent":"0eed95861bdfe3a8","children":[],"id":"108204f27d47f6f6","title":"操作Collection、Map的工具类"},{"parent":"0eed95861bdfe3a8","children":[{"parent":"ca53e19e37e7ce0d","children":[],"id":"5cdb92b2309d480f","title":"Collection是集合类的上级接口，继承于他的接口主要有Set 和List"},{"parent":"ca53e19e37e7ce0d","children":[],"id":"c1e5cd51a60466a5","title":"Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作（均为静态方法）"}],"id":"ca53e19e37e7ce0d","title":"和Collection区别"}],"id":"0eed95861bdfe3a8","title":"Collections工具类"}],"root":true,"theme":"theme3","id":"root","title":"Java集合","structure":"mind_right"}},"meta":{"exportTime":"2021-07-25 16:50:18","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-19 17:38:04","modified":"2021-07-25 16:50:15","title":"Java集合","category":"outline"},"id":"60f547fc637689739c3e2261","type":"ProcessOn Schema File","version":"1.0"}}