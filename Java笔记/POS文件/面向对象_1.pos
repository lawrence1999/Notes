{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"c0c018dbb7502f13","children":[],"id":"8032f61a1cb707da","title":"如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器。<br>"},{"parent":"c0c018dbb7502f13","children":[],"id":"4b5f2a4f283cb642","title":"定义构造器的格式&nbsp;权限修饰符 类名(形参列表) { }"},{"parent":"c0c018dbb7502f13","children":[],"id":"126e34267ef87542","title":"一旦显示的定义了类的构造器之后，系统不再提供默认的空参构造器"},{"parent":"c0c018dbb7502f13","children":[],"id":"7dff14bde1b7d10d","title":"一个类中定义的多个构造器，彼此构成重载"},{"parent":"c0c018dbb7502f13","children":[],"id":"be0c2213f354ad35","title":".一个类中，至少会有一个构造器&nbsp;"}],"id":"c0c018dbb7502f13","title":"构造器（构造方法 constructor）"},{"parent":"root","children":[{"parent":"82319e755b9c4682","children":[],"id":"6c7d674ade45281a","title":"用来修饰、调用：属性、方法、构造器"},{"parent":"82319e755b9c4682","children":[],"id":"59d61e604e2180d2","title":"修饰属性和方法:this 理解为：当前对象,或当前正在创建的对象<br>"},{"parent":"82319e755b9c4682","children":[],"id":"6dd14b1519663a35","title":"在类的方法中，我们可以使用\"this.属性\"或\"this.方法\"的方式，调用当前对象属性和方法，通常情况下，我们都选择省略“this.”"},{"parent":"82319e755b9c4682","children":[],"id":"fcef36eef1d943d5","title":"特殊情况下，如果方法的形参和类的属性同名，我们必须显式的使用\"this.变量\"的方式，表明此变量是属性，而非形参<br>"},{"parent":"82319e755b9c4682","children":[],"id":"94b3b1bb1cfaa44f","title":"在类的构造器中，我们可以使用\"this.属性\"或\"this.方法\"的方式，调用正在创建的对象属性和方法"},{"parent":"82319e755b9c4682","children":[{"parent":"51b80fcfec0e6fef","children":[],"id":"9dc384be0a777b24","title":"我们可以在类的构造器中，显式的使用\"this(形参列表)\"的方式，调用本类中重载的其他的构造器"},{"parent":"51b80fcfec0e6fef","children":[],"id":"fa66d8596a072672","title":"&nbsp;构造器中不能通过\"this(形参列表)\"的方式调用自己"},{"parent":"51b80fcfec0e6fef","children":[],"id":"c83f3c9f7456822c","title":"&nbsp;如果一个类中声明了n个构造器，则最多有n -1个构造器中使用了\"this(形参列表"},{"parent":"51b80fcfec0e6fef","children":[],"id":"181bf0a65a2be619","title":"this(形参列表)\"必须声明在类的构造器的首行"},{"parent":"51b80fcfec0e6fef","children":[],"id":"36c5685054488bf4","title":"在类的一个构造器中，最多只能声明一个\"this(形参列表）"}],"id":"51b80fcfec0e6fef","title":"this 调用构造器<br>"}],"id":"82319e755b9c4682","title":"关键字this"},{"parent":"root","children":[{"parent":"6a0745dd32ce00e2","children":[{"parent":"76ee739c2301c19d","children":[],"id":"deb0b164d8cf41bd","title":"import关键字的使用<br>"},{"parent":"76ee739c2301c19d","children":[],"id":"4ef90f72efc82411","title":"为了更好的实现项目中类的管理，提供包的概念"},{"parent":"76ee739c2301c19d","children":[],"id":"98dc2c5358badf8e","title":"使用 package 声明类或接口所属的包，声明在源文件的首行"},{"parent":"76ee739c2301c19d","children":[],"id":"067056b0efb95f73","title":".包，属于标识符，遵循标识符的命名规则、规范\"见名知意\""},{"parent":"76ee739c2301c19d","children":[],"id":"b3b5f3d90f8880c5","title":"同一个包下，不能命名同名接口或同名类，不同包下，可以命名同名的接口、类"}],"id":"76ee739c2301c19d","title":"package 关键字的使用<br>"},{"parent":"6a0745dd32ce00e2","children":[{"parent":"9fc593e360b2992e","children":[],"id":"2199bf268154b264","title":"声明在包的声明和类的声明之间"},{"parent":"9fc593e360b2992e","children":[],"id":"e6f8d8ac190bda1a","title":"如果需要导入多个结构，则并列写出即可"},{"parent":"9fc593e360b2992e","children":[],"id":"bbb7507683c37626","title":".可以使用\"xxx.*\"的方式,表示可以导入xxx包下的所有结构"},{"parent":"9fc593e360b2992e","children":[],"id":"61503254937a31f6","title":"在源文件中显式的使用import结构导入指定包下的类、接口"},{"parent":"9fc593e360b2992e","children":[],"id":"e6f946bfe14b3da2","title":"如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句"},{"parent":"9fc593e360b2992e","children":[],"id":"99ce45c693bf2aa6","title":"如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类"},{"parent":"9fc593e360b2992e","children":[],"id":"db51cbbeab0e8764","title":"如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入"},{"parent":"9fc593e360b2992e","children":[],"id":"de3eb775aecde1e5","title":"import static组合的使用：调用指定类或接口下的静态的属性或方法，然后可以直接使用"}],"id":"9fc593e360b2992e","title":"import的使用"}],"id":"6a0745dd32ce00e2","title":"关键字：package、import 的使用"},{"parent":"root","children":[{"parent":"5388afcfd7759e1b","children":[],"id":"e75b5aab4327c94d","title":"MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性"},{"parent":"5388afcfd7759e1b","image":{"w":528,"h":182,"url":"http://cdn.processon.com/60fac2670791294ae09eaf25?e=1627050103&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:HXvsaS-81lGkH4wM9bxF8N5mVRg="},"children":[],"id":"314fc16e4a2169d3","title":""},{"parent":"5388afcfd7759e1b","image":{"w":365,"h":282,"url":"http://cdn.processon.com/60fac26be401fd7e997a168b?e=1627050108&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:KViNXTbH7Pgac_iPsmgDsymb8Lo="},"children":[],"id":"9bc593c8892ae34b","title":""}],"id":"5388afcfd7759e1b","title":"MVC设计模式"}],"children":[{"parent":"root","children":[],"id":"21cb5e2967744ece","title":"面向对象特征：封装、继承、多态性、(抽象性)"},{"parent":"root","children":[{"parent":"4f9a3b309a49cca2","image":{"w":436,"h":314,"url":"http://cdn.processon.com/60fad3e91e085366ea4c8a6e?e=1627054585&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:FlFV346_0vW-PlR2djLXnrrhtbs="},"children":[],"id":"532a484d1b88d012","title":""},{"parent":"4f9a3b309a49cca2","children":[],"id":"583d6fdc9157546c","title":"堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。<br>"},{"parent":"4f9a3b309a49cca2","children":[],"id":"5061f5920ef29f58","title":"通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。"},{"parent":"4f9a3b309a49cca2","children":[],"id":"f0f2d212d6071406","title":"方法区（MethodArea），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据"},{"parent":"4f9a3b309a49cca2","children":[],"id":"cf9caa3338671535","title":"创建是对象存储在栈中，指向堆中存放该实例的首地址"}],"id":"4f9a3b309a49cca2","title":"对象的创建和使用：内存解析"},{"parent":"root","children":[{"parent":"de9833e900ac93db","children":[{"parent":"98b18e2b14c816ab","children":[],"id":"fe1c009b5fdab24f","title":"定义变量的格式:数据类型 变量名 = 变量值<br>"},{"parent":"98b18e2b14c816ab","children":[],"id":"8a3e768d138e924c","title":"&nbsp;先声明，后使用"},{"parent":"98b18e2b14c816ab","children":[],"id":"3e939576ebb98832","title":"变量都有其对应的作用域"}],"id":"98b18e2b14c816ab","title":"同"},{"parent":"de9833e900ac93db","children":[{"parent":"cc222d52ce59dbb1","children":[],"id":"e3ab34e408cb5830","title":"在类中声明的位置不同， 属性:直接定义在类的一对{}内，局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量，，关于权限修饰符的不同， 属性:可以在声明属性时，指明其权限，使用权限修饰符<br>"},{"parent":"cc222d52ce59dbb1","children":[],"id":"514c26ba5d4821a0","title":"属性:可以在声明属性时，指明其权限，使用权限修饰符常用的权限修饰符:private、public、缺省、protected，局部变量:不可以使用权限修饰符"},{"parent":"cc222d52ce59dbb1","children":[],"id":"1535b6f013f2c97a","title":"属性:类的属性，根据其类型，都有默认初始化值，局部变量:没有默认初始化值，意味着:在调用局部变量之前，一定要显式赋值<br>"},{"parent":"cc222d52ce59dbb1","children":[],"id":"cd2c7429bbeca1e3","title":"在内存中加载的位置，亦各不相同，属性:加载到堆空间中(非 static)，局部变量:加载到栈空间<br>"}],"id":"cc222d52ce59dbb1","title":"异"}],"id":"de9833e900ac93db","title":"属性（成员变量）和局部变量的异同"},{"parent":"root","children":[{"parent":"6cba1d4151c053ea","children":[],"id":"9aaf62fc022319c7","title":"方法的声明&nbsp;权限修饰符 返回值类型 方法名(形参列表){方法体}"},{"parent":"6cba1d4151c053ea","children":[],"id":"9e0d6e384efcec41","title":"&nbsp;方法的使用中，可以调用当前类的属性或方法<br>"},{"parent":"6cba1d4151c053ea","children":[],"id":"64bad9ab7ee9aec1","title":"方法中不能定义其他方法"},{"parent":"6cba1d4151c053ea","children":[{"parent":"003e0786e5117dc2","children":[],"id":"94203e08f2c838b1","title":"我们创建的对象，没有显示的赋值给一个变量名。即为匿名对象。匿名对象只能调用一次<br>"},{"parent":"003e0786e5117dc2","children":[],"id":"4a1d6a6fee5d9782","title":"new person().eat()"}],"id":"003e0786e5117dc2","title":"匿名对象"},{"parent":"6cba1d4151c053ea","children":[{"parent":"69920c5383a090de","children":[],"id":"63b2925af4018e7e","title":"在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可"},{"parent":"69920c5383a090de","children":[],"id":"452bf343526e1a8a","title":"同一个类、相同方法名，参数列表不同：参数个数不同，参数类型不同<br>"}],"id":"69920c5383a090de","title":"重置（overload）"},{"parent":"6cba1d4151c053ea","children":[{"parent":"eb67ff11c8c9062e","children":[],"id":"741d1c1a13864acc","title":"可变个数形参的格式：数据类型 ... 变量名或者是 String[] args"},{"parent":"eb67ff11c8c9062e","children":[],"id":"4bf54469c27c6f20","title":"可变个数形参在方法中的形参中,必须声明在末尾"},{"parent":"eb67ff11c8c9062e","children":[],"id":"a2b85e911eafaab8","title":"可变个数形参在方法中的形参中，最多只能声明一个可变形参"},{"parent":"eb67ff11c8c9062e","children":[],"id":"5ea62ab3f3f85525","title":"4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。即二者不可共存"}],"id":"eb67ff11c8c9062e","title":"可变个数的形参"},{"parent":"6cba1d4151c053ea","children":[{"parent":"3924df4fba4e3f0d","children":[],"id":"a1c80a09138ac64f","title":"如果变量是基本数据类型，此时赋值的是变量所保存的数据值，形参的int交换不会影响外面的值"},{"parent":"3924df4fba4e3f0d","children":[],"id":"fcfe1f7dd83d9088","title":"如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值，形参的Integer交换会影响外面的值"}],"id":"3924df4fba4e3f0d","title":"方法参数的值传递机制【重点】","icons":[{"color":"rgb(191, 30, 27)","name":"flag","index":"28","text":"&#xe67e"}]}],"id":"6cba1d4151c053ea","title":"方法"},{"parent":"root","children":[{"parent":"eb7715f9eddff281","children":[],"id":"91d3700b517b528b","title":"封装性的体现：我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)<br>"},{"parent":"eb7715f9eddff281","children":[{"parent":"e927f209b3fb2a0f","image":{"w":574,"h":129,"url":"http://cdn.processon.com/60fac1bb1e085366ea4c7de3?e=1627049931&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:hyDGL6NbYEZ1GQS6rzCWgycYdbQ="},"children":[],"id":"9169e607b4c7380e","title":""}],"collapsed":false,"id":"e927f209b3fb2a0f","title":"四种权限修饰符"},{"parent":"eb7715f9eddff281","children":[{"parent":"c1af0b0491dd8b7b","children":[],"id":"95cf0e179c973415","title":"public 类可以在任意地方被访问<br>"},{"parent":"c1af0b0491dd8b7b","children":[],"id":"1d84793f2a1bf493","title":"default 类只可以被同一个包内部的类访问"}],"id":"c1af0b0491dd8b7b","title":"对于 class 的权限修饰只可以用 public 和 default(缺省)"}],"id":"eb7715f9eddff281","title":"面向对象特征之一：封装与隐藏"}],"root":true,"theme":"theme3","id":"root","title":"面向对象_1","structure":"mind_free"}},"meta":{"exportTime":"2021-07-24 17:24:07","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-23 17:59:03","modified":"2021-07-24 17:23:55","title":"面向对象_1","category":"outline"},"id":"60fa92e75653bb3ddc0ffa5b","type":"ProcessOn Schema File","version":"1.0"}}