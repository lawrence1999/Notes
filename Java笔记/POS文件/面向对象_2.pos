{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"67e87a6248d6a56b","children":[],"id":"7b4bf04c7b153390","title":"对象的多态性:父类的引用指向子类的对象(或子类的对象赋值给父类的引用)，Person p2 = new Man();"},{"parent":"67e87a6248d6a56b","children":[{"parent":"a2b1679dd0275a1a","children":[],"id":"850070a8efdb16c7","title":"&nbsp;“看左边”：看的是父类的引用（父类中不具备子类特有的方法）"},{"parent":"a2b1679dd0275a1a","children":[],"id":"d86ed580dd432bd8","title":"看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）"}],"id":"a2b1679dd0275a1a","title":"多态情况下<br>"},{"parent":"67e87a6248d6a56b","children":[],"id":"5279524dd9616104","title":"若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism）"},{"parent":"67e87a6248d6a56b","children":[{"parent":"b65449de2185ed8d","children":[],"id":"d18997dd186cbbe8","title":"&nbsp;类的继承关系"},{"parent":"b65449de2185ed8d","children":[],"id":"79bf895b9c36b420","title":"方法的重写"}],"id":"b65449de2185ed8d","title":"多态性的使用前提：<br>"},{"parent":"67e87a6248d6a56b","children":[],"id":"53821492f0ca4d9e","title":"虚拟方法调用，有了对象多态性以后，我们在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法，，简称：编译时，看左边；运行时，看右边"},{"parent":"67e87a6248d6a56b","children":[],"id":"1c0771fd988aa8e1","title":"对象的多态性:只适用于方法，不适用于属性(编译和运行都看左边)"},{"parent":"67e87a6248d6a56b","children":[],"id":"514db91d9688e179","title":"向下转型前先用instanceOf进行判断"},{"parent":"67e87a6248d6a56b","children":[],"id":"43773424cf840e39","title":"多态是编译行为还是运行行为？运行行为"},{"parent":"67e87a6248d6a56b","image":{"w":506,"h":274,"url":"http://cdn.processon.com/60fb868d1efad46a20a3226a?e=1627100323&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iVjmnMQCXwcK_wiEODLALezxUp0="},"children":[],"id":"03664f76cfb22b4d","title":""}],"id":"67e87a6248d6a56b","title":"面向对象的特征三：多态性"},{"parent":"root","children":[{"parent":"83a90afcd1d3ced8","children":[],"id":"6c96d23b383bdcfe","title":"Object类是所有Java类的根父类;<br>"},{"parent":"83a90afcd1d3ced8","children":[],"id":"d3a1cfb2204c3cf3","title":"如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类"},{"parent":"83a90afcd1d3ced8","children":[],"id":"66471f673f25ecac","title":"Object类中的功能(属性、方法)就具有通用性"},{"parent":"83a90afcd1d3ced8","children":[{"parent":"1c693cba96ac508b","children":[{"parent":"09a742d5e62b59c7","children":[],"id":"9c687b0367bbe870","title":"可以使用在基本数据类型变量和引用数据类型变量中"},{"parent":"09a742d5e62b59c7","children":[],"id":"9a380d48e356524d","title":"如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。(不一定类型要相同)"},{"parent":"09a742d5e62b59c7","children":[],"id":"fee0a971b2184080","title":"如果比较的是引用数据类型变量：比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体"}],"id":"09a742d5e62b59c7","title":"== : 运算符<br>"},{"parent":"1c693cba96ac508b","children":[{"parent":"3e7451a93a7d88f4","children":[],"id":"92966d07585afe9d","title":"是一个方法，而非运算符"},{"parent":"3e7451a93a7d88f4","children":[],"id":"00356e45963b5b7c","title":"只能适用于引用数据类型"},{"parent":"3e7451a93a7d88f4","children":[],"id":"7385735e249db971","title":"Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体"},{"parent":"3e7451a93a7d88f4","children":[],"id":"ef1c0af593789b7d","title":"Object类中equals()的定义： * \t\tpublic boolean equals(Object obj){ * \t\t\treturn (this == obj);"},{"parent":"3e7451a93a7d88f4","children":[],"id":"006ce460aaead3cb","title":"像String、Date、File、包装类等都重写了Object类中的equals()方法. * \t 两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同"},{"parent":"3e7451a93a7d88f4","children":[],"id":"a9a3e5c02a5c870f","title":"通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的\"实体内容\"是否相同。那么，我们 * \t   就需要对Object类中的equals()进行重写"},{"parent":"3e7451a93a7d88f4","children":[],"id":"1207d117933ee3ee","title":"重写的原则:比较两个对象的实体内容是否相同"}],"id":"3e7451a93a7d88f4","title":"equals()方法的使用<br>"}],"id":"1c693cba96ac508b","title":"==和equals的区别"},{"parent":"83a90afcd1d3ced8","children":[],"id":"2aae8ac82c8a39ca","title":"toString类"}],"id":"83a90afcd1d3ced8","title":"Object类"},{"parent":"root","children":[{"parent":"b3ddeecdef32b50b","image":{"w":658,"h":355,"url":"http://cdn.processon.com/60fb868d1efad46a20a3226a?e=1627100323&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iVjmnMQCXwcK_wiEODLALezxUp0="},"children":[],"id":"e4229aae29da4930","title":""}],"id":"b3ddeecdef32b50b","title":"包装类（Wrapper）"}],"children":[{"parent":"root","children":[{"parent":"a90143ab31680872","children":[],"id":"c4b769b2d18d7b7d","title":"多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可<br>"},{"parent":"a90143ab31680872","task":{},"children":[],"id":"976a0936d4c34da8","title":"格式 class A extends B{}"},{"parent":"a90143ab31680872","children":[],"id":"f668de4e54ee1e46","title":"一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构：属性、方法<br>"},{"parent":"a90143ab31680872","children":[],"id":"cb3093481f9d32f7","title":"特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构"},{"parent":"a90143ab31680872","children":[],"id":"5e9a18f6bb95c6ea","title":"只有因为封装性的影响，使得子类不能直接调用父类的结构而已"},{"parent":"a90143ab31680872","children":[],"id":"30959f6fe75c3b61","title":"类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展"},{"parent":"a90143ab31680872","children":[{"parent":"5c445a4ef66333a1","children":[],"id":"aac0bf207ee91856","title":".一个类可以被多个类继承<br>"},{"parent":"5c445a4ef66333a1","children":[],"id":"146cb3f73f29d933","title":"Java 中类的单继承性：一个类只能有一个父类"},{"parent":"5c445a4ef66333a1","children":[],"id":"21b0e4692d650349","title":"子父类是相对的概念"},{"parent":"5c445a4ef66333a1","children":[],"id":"f303d881f89dc360","title":"子类直接继承的父类，称为：直接父类。间接继承的父类，称为，间接父类"},{"parent":"5c445a4ef66333a1","children":[],"id":"be5207df0762f1a3","title":"类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法"}],"id":"5c445a4ef66333a1","title":"Java中关于继承的规定"}],"id":"a90143ab31680872","title":"面向对象的特征二:继承性"},{"parent":"root","children":[{"parent":"f518da55d3b0403d","children":[],"id":"17de18f7c9a465dc","title":"子类继承父类以后，可以对父类中的方法进行覆盖操作<br>"},{"parent":"f518da55d3b0403d","children":[],"id":"054095bf07c4ba9b","title":"重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法"},{"parent":"f518da55d3b0403d","children":[{"parent":"4a69bcfdb1aa3aa3","children":[],"id":"d6e852e54934d504","title":"方法的重写Overriding和重载Overloading是Java多态性的不同表现。<br>重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现<br>&nbsp;如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。<br>子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。<br>&nbsp;如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)<br>"}],"id":"4a69bcfdb1aa3aa3","title":"重写和重载的异同"},{"parent":"f518da55d3b0403d","children":[{"parent":"778eb160095ae0fc","children":[],"id":"61af32041147fb4f","title":"子类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同<br>"},{"parent":"778eb160095ae0fc","children":[],"id":"5469ccb2146d91ea","title":"子类不能重写父类中声明为private权限的方法"},{"parent":"778eb160095ae0fc","children":[],"id":"02c40739602a480d","title":"子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限"},{"parent":"778eb160095ae0fc","children":[],"id":"bd13c1e87b669fd3","title":"子类方法抛出的异常不能大于父类被重写的方法抛出的异常"},{"parent":"778eb160095ae0fc","children":[],"id":"d6be1c518cf4f9b1","title":"子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写），因为static方法是属于类的，子类无法覆盖父类的方法<br>"},{"parent":"778eb160095ae0fc","children":[{"parent":"b27b031cbe89714f","children":[],"id":"09627afb097cf805","title":"父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类;"},{"parent":"b27b031cbe89714f","children":[],"id":"c77780112784faa0","title":"父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void;"},{"parent":"b27b031cbe89714f","children":[],"id":"2f3bcc56b7a6b650","title":"&nbsp;父类被重写的方法的返回值类型如果是基本数据类型(比如:double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须是:double)"}],"id":"b27b031cbe89714f","title":"返回值类型<br>"}],"id":"778eb160095ae0fc","title":"重写的规定"}],"id":"f518da55d3b0403d","title":"重写（override/overwrite）"},{"parent":"root","children":[{"parent":"1e43186edd2437c8","children":[],"id":"19db9f65258eb046","title":"super可以用来调用:属性、方法、构造器&nbsp;"},{"parent":"1e43186edd2437c8","children":[],"id":"7ccec3029ee24311","title":"&nbsp;我们可以在子类的方法或构造器中，通过\"super.属性\"或\"super.方法\"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯去省略这个\"super.\"<br>"},{"parent":"1e43186edd2437c8","children":[],"id":"96dfd90886f28211","title":"当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用\"super.属性\"的方式，表明调用的是父类中声明的属性"},{"parent":"1e43186edd2437c8","children":[],"id":"035e4c3a49e67945","title":"特殊情况:当子类重写了父类中的方法后，我们想在子类的方法中调用父类中被重写的方法时，必须显式的 *  使用\"super.方法\"的方式，表明调用的是父类中被重写的方法"},{"parent":"1e43186edd2437c8","children":[{"parent":"647f256371d1f891","children":[],"id":"f7a5496898743892","title":"我们可以在子类的构造器中显式的使用\"super(形参列表)\"的方式,调用父类中声明的指定的构造器"},{"parent":"647f256371d1f891","children":[],"id":"46c15d4d3a5fd90f","title":"\"super(形参列表)\"的使用，必须声明在子类构造器的首行"},{"parent":"647f256371d1f891","children":[],"id":"ed48d9d21c7f6d54","title":"&nbsp;我们在类的构造器中，针对于\"this(形参列表)\"或\"super(形参列表)\"只能二选一，不能同时出现"},{"parent":"647f256371d1f891","children":[],"id":"a50110a7e64c80fd","title":"在构造器的首行，既没有显式的声明\"this(形参列表)\"或\"super(形参列表)\",则默认的调用的是父类中的空参构造器。super()"},{"parent":"647f256371d1f891","children":[],"id":"3de462e0613f33cd","title":"在类的多个构造器中，至少有一个类的构造器使用了\"super(形参列表)\",调用父类中的构造器"}],"id":"647f256371d1f891","title":"super调用构造器"}],"id":"1e43186edd2437c8","title":"Super关键字"}],"root":true,"theme":"theme3","id":"root","title":"面向对象_2","structure":"mind_free"}},"meta":{"exportTime":"2021-07-24 17:24:42","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-23 22:38:06","modified":"2021-07-24 17:24:30","title":"面向对象_2","category":"outline"},"id":"60fad44e0e3e7423a326e77d","type":"ProcessOn Schema File","version":"1.0"}}