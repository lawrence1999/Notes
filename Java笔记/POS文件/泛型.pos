{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[],"id":"a85d9c8fdb76e4d1","title":"泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;<br><br>泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass(){}<br><br>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。<br><br>泛型不同的引用不能相互赋值。尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。<br><br>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。<br>经验：泛型要使用一路都用。要不用，一路都不要用。<br><br>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。<br><br>jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList&lt;&gt;();<br><br>泛型的指定中不能使用基本数据类型，可以使用包装类替换。<br><br>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。<br><br>异常类不能是泛型的<br>不能使用new E[]，但是可以：E[] elements = (E[]) new Object&nbsp; [capacity]<br>"},{"parent":"root","children":[],"id":"2d8e805e7504485a","title":"泛型方法&nbsp; 可以使用静态 泛型参数是在调用方法确定的 不是实例化确定的&nbsp; 泛型类中不可以，因为他是实例化才能确定，而静态方法在实例化之前 public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr)&nbsp; Integer[] arr = new Integer[]{1,2,3,4};<br>泛型方法在调用时，指明泛型参数的类型&nbsp; &nbsp;Integer[] arr = new Integer[]{1,2,3,4};&nbsp; List&lt;Integer&gt; list = order.copyFromArrayToList(arr)"}],"root":true,"theme":"theme3","id":"root","title":"泛型","structure":"mind_right"}},"meta":{"exportTime":"2021-07-25 16:49:53","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-20 21:19:11","modified":"2021-07-25 16:49:43","title":"泛型","category":"outline"},"id":"60f6cd4ff346fb79c53e0ab0","type":"ProcessOn Schema File","version":"1.0"}}