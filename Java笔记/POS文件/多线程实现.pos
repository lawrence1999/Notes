{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"26dc603f21b89dae","children":[{"parent":"98a93783950f3540","children":[],"id":"6fa68c219fa931e2","title":"class MyThread extends Thread&nbsp; &nbsp; &nbsp; 重写run()方法"},{"parent":"98a93783950f3540","children":[],"id":"821d1bc8e3a0cb71","title":"MyThread mythread = new MyThread（）"}],"collapsed":false,"id":"98a93783950f3540","title":"继承Thread类"},{"parent":"26dc603f21b89dae","children":[{"parent":"9c9a19991ac1ece0","children":[],"id":"fcd6187996f3e83d","title":"class Mythread implements Runnable&nbsp; &nbsp; &nbsp; 重写run方法"},{"parent":"9c9a19991ac1ece0","children":[],"id":"d747e6eaaf88410f","title":"Mythread mythread = new MyThread(); Thread t1 = new Thread(mythread)"}],"collapsed":false,"id":"9c9a19991ac1ece0","title":"实现Runnable接口"},{"parent":"26dc603f21b89dae","children":[{"parent":"069c21de902cf0b3","children":[],"id":"84d5f83f7d173903","title":"class Mythread implements Callable&nbsp; 重写call()方法"},{"parent":"069c21de902cf0b3","children":[],"id":"9a3f660d54d285e7","title":"Mythread mythread&nbsp; = new Mythread; FutureTask futuretask = new FutureTask(mythread); new Thread(futuretask).start()"},{"parent":"069c21de902cf0b3","children":[{"parent":"1b8d518a328b1e70","children":[],"id":"1454294d025bcaeb","title":"call()可以有返回值的"},{"parent":"1b8d518a328b1e70","children":[],"id":"b6a63cd0a2e795a6","title":"call()可以抛出异常，被外面的操作捕获，获取异常的信息"},{"parent":"1b8d518a328b1e70","children":[],"id":"d58c21732b54c569","title":"Callable是支持泛型的"},{"parent":"1b8d518a328b1e70","children":[],"id":"e03833d1c92ad568","title":"需要借助FutureTask类，比如获取返回结果"}],"id":"1b8d518a328b1e70","title":"实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？<br>"}],"collapsed":false,"id":"069c21de902cf0b3","title":"实现Callable接口&nbsp;"},{"parent":"26dc603f21b89dae","children":[{"parent":"36c7c05956d9b5b8","children":[],"id":"6ec1e113a087bf2f","title":"提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具"}],"id":"36c7c05956d9b5b8","title":"线程池"}],"id":"26dc603f21b89dae","title":"多线程实现"},{"parent":"root","children":[{"parent":"6139aaa9d5a3c534","children":[{"parent":"4fd9a028b5831e69","children":[],"id":"b62bf25686b18368","title":"sychronized（lock）{}"}],"id":"4fd9a028b5831e69","title":"同步代码块&nbsp;&nbsp;"},{"parent":"6139aaa9d5a3c534","children":[{"parent":"a279ba1eb3f2dff2","children":[],"id":"15d4e7d43c67233f","title":"public sychronized void function（lock）{}"}],"id":"a279ba1eb3f2dff2","title":"同步方法"},{"parent":"6139aaa9d5a3c534","children":[{"parent":"159a0e4f45c93431","children":[],"id":"c1e471ea0a191af9","title":"private ReentrantLock lock = new ReentrantLock();"},{"parent":"159a0e4f45c93431","children":[],"id":"72b2ff2bc3cdfc38","title":"try{lock.lock()} final {lock.unlock()}"}],"id":"159a0e4f45c93431","title":"lock"},{"parent":"6139aaa9d5a3c534","children":[{"parent":"1dd3150e69ff88e6","children":[],"id":"ff224d94a40b9ad1","title":"Lock的机制，在继承和实现中this的使用，注意不同实例是否相同；"},{"parent":"1dd3150e69ff88e6","children":[],"id":"414c0960a01aca21","title":"线程阻塞： wait()&nbsp; notify()/notifyAll() 解锁，在object中定义（对应于锁） 在同步代码块使用 ；sleep()随时可以使用 ，在Thread中定义"}],"id":"1dd3150e69ff88e6","title":"注"}],"id":"6139aaa9d5a3c534","title":"线程同步"}],"root":true,"theme":"theme3","id":"root","title":"多线程","structure":"mind_right"}},"meta":{"exportTime":"2021-07-25 16:48:50","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-18 23:34:09","modified":"2021-07-24 21:48:53","title":"多线程实现","category":"outline"},"id":"60f449f15653bb0b488a6c45","type":"ProcessOn Schema File","version":"1.0"}}