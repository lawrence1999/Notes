{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"b377ccc247cb3511","children":[],"id":"243c9a5e8c35114f","title":"转换流提供了在字节流和字符流之间的转换"},{"parent":"b377ccc247cb3511","children":[],"id":"d4af2f32833e1c49","title":"InputStreamReader：将InputStream转换为Reader 实现将字节的输入流【按指定字符集】转换为字符的输入流&nbsp;需要和InputStream“套接&nbsp; 【解码】<br>"},{"parent":"b377ccc247cb3511","children":[],"id":"9598eeeebeb34d64","title":"OutputStreamWriter：将Writer转换为OutputStream 实现将字符的输出流【按指定字符集】转换为字节的输出流&nbsp;&nbsp;需要和OutputStream“套接 【编码】"},{"parent":"b377ccc247cb3511","children":[],"id":"67e113aa8ef3bd55","title":"使用类似于缓冲流 进行一次嵌套"}],"id":"b377ccc247cb3511","title":"转换流"},{"parent":"root","children":[{"parent":"784455649087980d","children":[],"id":"1fe008da3c0e37c4","title":"GBK对于是一个字节还是两个字节 看首位，最高位0是 是一个 1 是两个"},{"parent":"784455649087980d","children":[],"id":"78941e9b5b9a6df3","title":"UTF是看首字节的数是0/10/110/1110"},{"parent":"784455649087980d","children":[],"id":"7b8598df027eb2b8","title":"&nbsp;* ASCII：美国标准信息交换码 用一个字节的7位可以表示。<br> *ISO8859-1：拉丁码表。欧洲码表&nbsp; 用一个字节的8位表示<br>  *  GB2312：中国的中文编码表。最多两个字节编码所有字符<br>  *  GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码<br>  *  Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。<br>  *  UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。<br>"},{"parent":"784455649087980d","image":{"w":340,"h":179,"url":"http://cdn.processon.com/60f92b4a0e3e742a34031694?e=1626945883&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:YYyVgyDZr3idWrs78zWne_HRFQw="},"children":[],"id":"151dbc182a68d0f1","title":""}],"id":"784455649087980d","title":"编码表"},{"parent":"root","children":[{"parent":"7e8ced7146fee178","children":[],"id":"6c53d193ff8476cf","title":"System.in和System.out分别代表了系统标准的输入和输出设备<br>"},{"parent":"7e8ced7146fee178","children":[],"id":"fdbadcd41b73222d","title":"默认输入设备是：键盘，输出设备是：显示器"},{"parent":"7e8ced7146fee178","children":[],"id":"c03651543a8e280a","title":"System.in的类型是InputStream"},{"parent":"7e8ced7146fee178","children":[],"id":"1a538e9c36b1e521","title":"System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类"},{"parent":"7e8ced7146fee178","children":[],"id":"dcea6bf1715007d5","title":"使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()"}],"id":"7e8ced7146fee178","title":"标准输入 输出流"},{"parent":"root","children":[],"id":"dea410ba8f81e769","title":"打印流"},{"parent":"root","children":[],"id":"bf181ab53ea70140","title":"数据流"}],"children":[{"parent":"root","children":[{"parent":"5e193ea08ab00020","children":[{"parent":"c35a2dcb9ed569b2","children":[],"id":"33bed14a7ebe4367","title":"File(String filePath):以filePath为路径创建File对象，可以是绝对路径或者相对路径<br>"},{"parent":"c35a2dcb9ed569b2","children":[],"id":"2a5646c9e4b85c09","title":"File(String parentPath,String childPath):以parentPath为父路径，childPath为子路径创建File对象。"},{"parent":"c35a2dcb9ed569b2","children":[],"id":"1b4ba8a7bced44a4","title":"File(File parentFile,String childPath):根据一个父File对象和子文件路径创建File对象"}],"id":"c35a2dcb9ed569b2","title":"实例化的三种方法"},{"parent":"5e193ea08ab00020","children":[],"id":"88bda1a944128eb7","title":"使用相对路径时，如果是main方法下式在Project下，其他方法（还是test方法【不确定】，因为DIDEA每次都要导入junit，是在当前module下，而ecilips是在project下）是在module下"},{"parent":"5e193ea08ab00020","children":[],"id":"e909a436a87d6175","title":"路径分隔符 windows:\\\\&nbsp;&nbsp;unix:/&nbsp; &nbsp;因为java支持跨平台 所以要慎用<br>"}],"id":"5e193ea08ab00020","title":"File类"},{"parent":"root","children":[{"parent":"8eee4d32da542d42","children":[],"id":"71ea69b8021278ca","title":"对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...)，使用字节流处理"},{"parent":"8eee4d32da542d42","children":[],"id":"2b186eacf47f6fa0","title":"&nbsp;对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理<br>"},{"parent":"8eee4d32da542d42","image":{"w":411,"h":231,"url":"https://cdn.processon.com/60f84a2c637689101a603586?e=1626888252&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Ix1PfI4qGjLqNeXi9-tH_L2Ugco="},"children":[],"id":"c003012e0064f06c","title":""}],"collapsed":false,"id":"8eee4d32da542d42","title":"IO流的分类"},{"parent":"root","children":[{"parent":"02f2f842e36030ce","children":[{"parent":"9835fd2ff7f68c1c","children":[],"id":"14c61079640f525d","title":"创建File类的对象，指明读入和写出的文件"},{"parent":"9835fd2ff7f68c1c","children":[],"id":"aedd494df021810c","title":"创建输入流和输出流的对象"},{"parent":"9835fd2ff7f68c1c","children":[],"id":"ebd18897008f110d","title":"数据的读入和写出操作"},{"parent":"9835fd2ff7f68c1c","children":[],"id":"c90c5acf2b3b9974","title":"关闭流资源"}],"id":"9835fd2ff7f68c1c","title":"通用步骤："},{"parent":"02f2f842e36030ce","children":[],"id":"978efe2a3ecb3dbc","title":"FileReader fr= new FileReader(new File(“Test.txt”));"},{"parent":"02f2f842e36030ce","children":[],"id":"e9cf76b6e45f1190","title":"read():返回读入的一个字符。如果达到文件末尾，返回-1，内部自带迭代"},{"parent":"02f2f842e36030ce","children":[],"id":"bc6e5dbf87a804ce","title":"异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理，close放在finally中，保证可以一定执行关闭&nbsp; 使用if(fr != null） fr.close();<br>"},{"parent":"02f2f842e36030ce","children":[],"id":"2f4063bc1ff39678","title":"read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1"},{"parent":"02f2f842e36030ce","children":[],"id":"f157e5a9351aa71f","title":"注意！！！！！！错误的写法::while((len = fr.read(cbuf)) != -1 ）{for(int i = 0;i &lt; cbuf.length;i++)}&nbsp; &nbsp;cbuf采用覆盖的方法，这样会每次都输出char[]的长度,应该是{for(int i = 0;i &lt; len;i++)}  "},{"parent":"02f2f842e36030ce","children":[],"id":"cb0325a0ec230ca2","title":"同理&nbsp;String str = new String(cbuf)也是错误的，应该是String str = new String(cbuf，0，len)"}],"id":"02f2f842e36030ce","title":"字符流（文件流）"},{"parent":"root","children":[{"parent":"8aea85a2963c8278","children":[],"id":"c3f691ac3ec4dfb6","title":"通用步骤：造文件 造流 读数据 关闭资源"},{"parent":"8aea85a2963c8278","children":[],"id":"bab8a1fb70d62a64","title":"和节点流基本类似，只是改变了访问文件名称（见上图）"}],"id":"8aea85a2963c8278","title":"字节流"},{"parent":"root","children":[{"parent":"c1fa76d84e705111","children":[],"id":"0a71947786f7cdd3","title":"为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。"},{"parent":"c1fa76d84e705111","children":[],"id":"e9a7e0355a6dd110","title":"是在节点流或者字节流的基础上构造的，bis = new BufferedInputStream(fis) 这里fis为节点流或者字节流,之后都使用bis，相当于进行了一次包装"},{"parent":"c1fa76d84e705111","children":[],"id":"eb2d3968f58aa3d4","title":"在关闭的时候，是外到内，但是对外层流执行close()的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略"},{"parent":"c1fa76d84e705111","children":[],"id":"01b64ff1bba16f05","title":"flush()&nbsp; 刷新缓冲区&nbsp; &nbsp; newLine()提供换行的操作"},{"parent":"c1fa76d84e705111","children":[],"id":"68d428ae2743d3ef","title":"读的时候可以使用readLine，源码判断为null 或者和之前的字符流/字节流一致"}],"id":"c1fa76d84e705111","title":"缓冲流"}],"root":true,"theme":"theme3","id":"root","title":"IO流","structure":"mind_free"}},"meta":{"exportTime":"2021-07-25 16:49:22","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-21 00:34:46","modified":"2021-07-25 16:49:06","title":"File类","category":"outline"},"id":"60f6fb26637689552b543234","type":"ProcessOn Schema File","version":"1.0"}}