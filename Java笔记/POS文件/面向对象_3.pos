{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"2ae15fceaaa93932","children":[],"id":"305be48eacd17f77","title":"final用来修饰一个类:此类不能被其他类所继承。 *比如:String类、System类、StringBuffer类"},{"parent":"2ae15fceaaa93932","children":[],"id":"d05ba03c903206ba","title":"final用来修饰变量:此时的\"变量\"(成员变量或局部变量)就是一个常量。名称大写，且只能被赋值一次"},{"parent":"2ae15fceaaa93932","children":[],"id":"08efa8a8a9e292ac","title":"final修饰一个方法:final标记的方法不能被子类重写"}],"id":"2ae15fceaaa93932","title":"关键字final"},{"parent":"root","children":[{"parent":"d4c41a261703cfc9","children":[],"id":"864137594db60aa6","title":"abstract 可以用来修饰的结构:类、方法"},{"parent":"d4c41a261703cfc9","children":[{"parent":"628a23a3f06ab866","children":[],"id":"daf760ec6cb5dc5f","title":"抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化全过程)"},{"parent":"628a23a3f06ab866","children":[],"id":"1c360f70d0e75590","title":"开发中，都会提供抽象类的子类，让子类对象实例化，实现相关的操作"}],"id":"628a23a3f06ab866","title":"abstract 修饰类:抽象类"},{"parent":"d4c41a261703cfc9","children":[{"parent":"98797d5991859863","children":[],"id":"499d51e85773fb26","title":"抽象方法，只有方法的声明，没有方法体，即没有{}"},{"parent":"98797d5991859863","children":[],"id":"663edb7c84e2418f","title":"包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法"}],"id":"98797d5991859863","title":"abstract 修饰方法:抽象方法"},{"parent":"d4c41a261703cfc9","children":[],"id":"ea89c372718d3b14","title":"abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类"},{"parent":"d4c41a261703cfc9","children":[],"id":"150db6072037835d","title":"创建匿名子类的对象，是在实例化某个抽象类的时候对类内的一些方法进行重写"}],"id":"d4c41a261703cfc9","title":"抽象类/抽象方法"},{"parent":"root","children":[{"parent":"4b32d84901bb3181","children":[],"id":"65e7e7b2e706409d","title":"在 Java 中:接口和类是并列的两个结构"},{"parent":"4b32d84901bb3181","children":[],"id":"e6721ae4e2ebcf1b","title":"Java 类可以实现多个接口 ---》弥补了 Java 单继承性的局限性"},{"parent":"4b32d84901bb3181","children":[],"id":"2fd467ca226c824f","title":"接口与接口之间是继承,而且可以多继承"},{"parent":"4b32d84901bb3181","children":[],"id":"2acd5159d15a0a7b","title":"Java 开发中，接口通过让类去实现(implements)的方式来使用。<br>"},{"parent":"4b32d84901bb3181","children":[],"id":"dc7d04b5d514dca1","title":"如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化"},{"parent":"4b32d84901bb3181","children":[],"id":"7e52fa5dbfc920bd","title":"如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类"},{"parent":"4b32d84901bb3181","children":[{"parent":"f7b9f46e25fe14b6","image":{"w":545,"h":221,"url":"http://cdn.processon.com/60fb91661efad46a20a33035?e=1627103095&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:HvCG_oCmzogk5TBJn58vzT6uH7Y="},"children":[],"id":"512aa3f20cfa65d8","title":""}],"id":"f7b9f46e25fe14b6","title":"接口和抽象类的对比"}],"id":"4b32d84901bb3181","title":"接口Interface"}],"children":[{"parent":"root","children":[{"parent":"725b9607c0aad2f7","children":[{"parent":"ef024cbc772889b3","children":[],"id":"8cc343b6b1898f7f","title":"属性:是否使用 static 修饰，又分为:静态属性 VS 非静态属性(实例变量)"},{"parent":"ef024cbc772889b3","children":[],"id":"a3c7c2a4c2868d02","title":"静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过静态变量去修改某一个变量时， * \t\t\t\t会导致其他对象调用此静态变量时，是修改过的"},{"parent":"ef024cbc772889b3","children":[{"parent":"5311125c5925f634","children":[],"id":"ae35e272136003c6","title":"静态变量随着类的加载而加载。可以通过\"类.静态变量\"的方式进行调用"},{"parent":"5311125c5925f634","children":[],"id":"99e3c274e41e6f53","title":"静态变量的加载要早于对象的创建"},{"parent":"5311125c5925f634","children":[],"id":"95aa1444e9e382b8","title":"&nbsp;由于类只会加载一次，则静态变量在内存中也只会存在一次。存在方法区的静态域中"}],"id":"5311125c5925f634","title":"static 修饰属性的其他说明"},{"parent":"ef024cbc772889b3","image":{"w":521,"h":278,"url":"http://cdn.processon.com/60fb916c5653bb3ddc1090d0?e=1627103100&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:He3T4luVdG5KoyeeAaWkkogIKcs="},"children":[],"id":"c59cbe77f4218ff5","title":""}],"id":"ef024cbc772889b3","title":"&nbsp;修饰属性:静态变量(或类变量)"},{"parent":"725b9607c0aad2f7","children":[{"parent":"98e572d109112cbe","children":[],"id":"0b7d2f75ac9b61e0","title":"在静态的方法内，不能使用 this 关键字、super 关键字<br>"},{"parent":"98e572d109112cbe","children":[],"id":"04ba8efdadfd0865","title":"关于静态属性和静态方法的使用，大家从生命周期的角度去理解"}],"id":"98e572d109112cbe","title":"修饰方法（静态方法）"}],"id":"725b9607c0aad2f7","title":"关键字Static&nbsp;"},{"parent":"root","children":[{"parent":"2714223c1102945a","children":[],"id":"f2232e4d046c171f","title":"所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例"},{"parent":"2714223c1102945a","children":[{"parent":"f682c0e67320421b","children":[],"id":"be84505b54b00916","title":"&nbsp;好处:饿汉式是线程安全的"},{"parent":"f682c0e67320421b","children":[],"id":"8cb1d5151d842a26","title":"坏处:对象加载时间过长&nbsp;"},{"parent":"f682c0e67320421b","children":[{"parent":"ed9d4099ea9ae54c","children":[],"id":"c9b91b6566f6ebca","title":".私有化类的构造器"},{"parent":"ed9d4099ea9ae54c","children":[],"id":"ca15c3ef255a47fa","title":"内部创见类的对象，要求此对象也必须声明为静态的"},{"parent":"ed9d4099ea9ae54c","children":[],"id":"3b5155a915b498f5","title":"提供公共的静态的方法，返回类的对象"}],"id":"ed9d4099ea9ae54c","title":"步骤："}],"id":"f682c0e67320421b","title":"饿汉式："},{"parent":"2714223c1102945a","children":[{"parent":"3daa6a7b3e18c4ec","children":[],"id":"9021c1499ec67729","title":"好处:延迟对象的创建"},{"parent":"3daa6a7b3e18c4ec","children":[],"id":"45f3a101413289c6","title":"&nbsp;坏处:目前的写法，会线程不安全"},{"parent":"3daa6a7b3e18c4ec","children":[{"parent":"bcde662eef319168","children":[],"id":"825b089b8b637597","title":"私有化类的构造器"},{"parent":"bcde662eef319168","children":[],"id":"206c72e345cb845f","title":"声明当前类对象，没有初始化,赋值为null。此对象也必须声明为 static 的<br>"},{"parent":"bcde662eef319168","children":[],"id":"67bbac8aa2ecb1a2","title":"声明 public、static 的返回当前类对象的方法"}],"id":"bcde662eef319168","title":"步骤:"}],"id":"3daa6a7b3e18c4ec","title":"懒汉式"}],"id":"2714223c1102945a","title":"单例设计模式（Singleton）"},{"parent":"root","children":[{"parent":"a86a0b02e840e1af","children":[{"parent":"c54f65f066787bd7","children":[],"id":"f5d5b0f25073702b","title":"内部可以有输出语句"},{"parent":"c54f65f066787bd7","children":[],"id":"fb5b7d138e85a16f","title":"随着类的加载而执行,而且只执行一次"},{"parent":"c54f65f066787bd7","children":[],"id":"99cf9b9a921ae0fb","title":"作用:初始化类的信息"},{"parent":"c54f65f066787bd7","children":[],"id":"efe04f4abebd19ae","title":"如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行"},{"parent":"c54f65f066787bd7","children":[],"id":"1f454594a432e491","title":"静态代码块的执行，优先于非静态代码块的执行"},{"parent":"c54f65f066787bd7","children":[],"id":"3a4f6cec63495cc0","title":"静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构"}],"id":"c54f65f066787bd7","title":"静态代码块<br>"},{"parent":"a86a0b02e840e1af","children":[{"parent":"885b6892dbb8207b","children":[],"id":"416c1808b0e00745","title":"内部可以有输出语句"},{"parent":"885b6892dbb8207b","children":[],"id":"4885d6e2afda7995","title":"随着对象的创建而执行"},{"parent":"885b6892dbb8207b","children":[],"id":"221626b521f9502e","title":"每创建一个对象，就执行一次非静态代码块"},{"parent":"885b6892dbb8207b","children":[],"id":"34a8a8fbc2294c0d","title":"作用:可以在创建对象时，对对象的属性等进行初始化"},{"parent":"885b6892dbb8207b","children":[],"id":"56461414aeec2c66","title":"如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行"},{"parent":"885b6892dbb8207b","children":[],"id":"3a68529a84cf1ff8","title":"非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法"}],"id":"885b6892dbb8207b","title":"非静态代码块<br>"}],"id":"a86a0b02e840e1af","title":"代码块"}],"root":true,"theme":"theme3","id":"root","title":"面向对象_3","structure":"mind_free"}},"meta":{"exportTime":"2021-07-24 17:25:23","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-24 11:19:33","modified":"2021-07-24 17:25:11","title":"面向对象_3","category":"outline"},"id":"60fb86c50791294ae09ef926","type":"ProcessOn Schema File","version":"1.0"}}