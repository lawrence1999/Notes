{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"845735104b9f65e0","children":[{"parent":"ad8e500fbe248572","children":[],"id":"5f0d456311c1a411","title":"String&nbsp; str1 = “abc”是在常量池（在方法区内）中创建了“abc”，利用栈中str1的地址指向它,&nbsp; &nbsp; \"=体现的是指向\""},{"parent":"ad8e500fbe248572","children":[],"id":"520c535cb58297b3","title":"String str2 = new String(\"abc\")是指在堆空间中创建（new）了对象，该对象的value值指向常量池中的“abc”，一共创建了两个对象"},{"parent":"ad8e500fbe248572","children":[],"id":"cc3e82c10bbabd9e","title":"常量池中的值不可变，当对某string进行操作时，常量池会开辟另外一个区域"},{"parent":"ad8e500fbe248572","children":[],"id":"1a8f424b6896a60d","title":"常量的拼接结果在常量池中，拼接中只要含有变量，拼接结果就在堆中（即新创建了对象），但是加了final仍然为常量"},{"parent":"ad8e500fbe248572","children":[],"id":"c60993fb19719bbc","title":"str2.intern() ==str1;intern方法是返回值在常量池中"}],"id":"ad8e500fbe248572","title":"不可变性"},{"parent":"845735104b9f65e0","children":[{"parent":"f0ccbc59d4b1d939","children":[{"parent":"316bfeb53cddfcd2","children":[],"id":"661e85e07b008c8f","title":"int num = Inter.parseInt(str1)"},{"parent":"316bfeb53cddfcd2","children":[],"id":"33a41e3dd9c35517","title":"&nbsp;String str = num +\"\"&nbsp; 或&nbsp; &nbsp;String str = String.valueOf(num)"}],"id":"316bfeb53cddfcd2","title":"基本数据类型/包装类"},{"parent":"f0ccbc59d4b1d939","children":[{"parent":"d4a351009ade5308","children":[],"id":"d9077a037cc3ac50","title":"Char[]&nbsp; char = str.toCharArray()"},{"parent":"d4a351009ade5308","children":[],"id":"08f63b173b4b4897","title":"String str = new String(char)"}],"id":"d4a351009ade5308","title":"字符数组char []"},{"parent":"f0ccbc59d4b1d939","children":[{"parent":"86f1cbc9cfa99e7a","children":[],"id":"43a9776090b97621","title":"解码 Byte[]&nbsp; bytes = str.getBytes(str,编码方式) ，编码方式不写即为默认"},{"parent":"86f1cbc9cfa99e7a","children":[],"id":"677ed6f1cbe2c6ca","title":"编码&nbsp; String str = new String(bytes,编码方式)"}],"id":"86f1cbc9cfa99e7a","title":"字节数组"}],"id":"f0ccbc59d4b1d939","title":"String与其他类的转换"}],"id":"845735104b9f65e0","title":"String类"},{"parent":"root","children":[{"parent":"670c6f028a84cf81","children":[{"parent":"74bd4eb2d27e7c2b","children":[],"id":"beabe58491f98a5c","title":"二者的区别仅仅在于Buffer是线程安全（synchronized）的，效率低；Builder是线程不安全的，效率高"},{"parent":"74bd4eb2d27e7c2b","children":[],"id":"2736cab23575e870","title":"StringBuffe str = new SringBuffer() 相当于 char[] str = new char[16]"},{"parent":"74bd4eb2d27e7c2b","children":[],"id":"d785bc8c782f8348","title":"扩容问题：如果原有的数据底层放不下，会扩容一个原来容量的二倍+2，将原来数组的元素复制到新的数组中"},{"parent":"74bd4eb2d27e7c2b","children":[],"id":"000c48e2cb185f16","title":"开发中建议用StringBuffer（int capacity）指定容量，防止多次扩容"},{"parent":"74bd4eb2d27e7c2b","children":[],"id":"345fea496a20bdd9","title":"常用方法与String相同的，是inplace操作，多了append，delete"}],"id":"74bd4eb2d27e7c2b","title":"性质"}],"id":"670c6f028a84cf81","title":"StringBuffer/StringBuilder类"},{"parent":"root","children":[{"parent":"f080ece4a4f53d45","children":[],"id":"72c78f490fbabcae","title":"时间戳 System.currentTimeMillis() 返回是毫秒，目前到19701.1.1的时间"},{"parent":"f080ece4a4f53d45","children":[{"parent":"e2958395570bcfb4","children":[],"id":"97064d6f744b17f0","title":"Date date1 = new Date()&nbsp; &nbsp;显示当前年月日时分秒&nbsp;Date.getTime()返回的也是毫秒数，同时间戳"},{"parent":"e2958395570bcfb4","children":[],"id":"af02df4626f006e4","title":"Date date1 = new Date(long )&nbsp; long型的时间戳 转换为年月日"}],"id":"e2958395570bcfb4","title":"java.util.Date类&nbsp;&nbsp;"},{"parent":"f080ece4a4f53d45","children":[{"parent":"096118a6d34929e2","children":[],"id":"035bd2c2c0c1ba50","title":"在数据库中的使用，对于数据库中Date类型，实例化中显示年月日，无时分秒"}],"id":"096118a6d34929e2","title":"java.sql.Date类"},{"parent":"f080ece4a4f53d45","children":[{"parent":"18b3808cf49f29d1","children":[],"id":"78b0c8fb58ea4046","title":"强转会报错（sql.Date有自己的属性）"},{"parent":"18b3808cf49f29d1","children":[],"id":"7cba018f1c4dcdb9","title":"利用getTime()作为桥梁，Date date1 = new Date() ;java.sql.Date date2 = new java.sql.Date(date1.getTime())"}],"id":"18b3808cf49f29d1","title":"java.util.Date（父类）转为java.sql.Date（子类）"},{"parent":"f080ece4a4f53d45","children":[{"parent":"31b652da8c706843","children":[{"parent":"5bc0260304c4d3b7","children":[],"id":"f0a652a48a5616e0","title":"SimpleDateFormat sdf = new SimpleDateFormat（pattern，比如“yyyy-MM-dd&nbsp; hh-mm-ss”）；Date date = new Date（）；String format = sdf.format(date)"}],"id":"5bc0260304c4d3b7","title":"格式化（日期→字符串）Date对象到自定义对象"},{"parent":"31b652da8c706843","children":[{"parent":"b38e0c25f190f86f","children":[],"id":"5c75e45e0dd0c483","title":"String str = \"2021-02-11&nbsp; 上午11：21\"（默认格式）; Date date = sdf.parse(str)"}],"id":"b38e0c25f190f86f","title":"解析（格式逆过程），格式和格式化一致"}],"id":"31b652da8c706843","title":"&nbsp;java.text.SimpleDateFormat类"},{"parent":"f080ece4a4f53d45","children":[{"parent":"c4c38e37bc90783b","children":[],"id":"9b2b9c143306285b","title":"Calenader cal = Calendar.getInstance()&nbsp; 获取当前时间"},{"parent":"c4c38e37bc90783b","children":[],"id":"ced072e2caee72f6","title":"get方法获取&nbsp; cal.get(int year)"},{"parent":"c4c38e37bc90783b","children":[],"id":"493ac7378b685e8e","title":"&nbsp;cal.set(Calendar.Year,2019) ,add（）,"},{"parent":"c4c38e37bc90783b","children":[],"id":"33614b972d5f9d0c","title":"Calendar 和Date转换&nbsp; Date date = cal.getTime() ;&nbsp; calendar.setTime(date)"}],"id":"c4c38e37bc90783b","title":"Calendar（日历类）抽象类"}],"id":"f080ece4a4f53d45","title":"JDK8之前 Date类"},{"parent":"root","children":[{"parent":"3b1ef8ce9bc69879","children":[{"parent":"d74f175d127062c9","children":[],"id":"90a8508ed083f9de","title":"LocalDate  localdate = LocalDate.now()  获取当前（yyyy-MM-dd）"},{"parent":"d74f175d127062c9","children":[],"id":"79f453058633832c","title":"LocalDate localdate = LocalDate.of(2020,1,3)&nbsp; 设置指定"}],"id":"d74f175d127062c9","title":"LocalDate&nbsp; &nbsp;&nbsp;"},{"parent":"3b1ef8ce9bc69879","children":[],"id":"9118b28bd5814efa","title":"LocalTime"},{"parent":"3b1ef8ce9bc69879","children":[],"id":"68ee07836d39c6c8","title":"LocalDateTime"},{"parent":"3b1ef8ce9bc69879","children":[],"id":"db440ee76fa00b2e","title":"Instant&nbsp;"},{"parent":"3b1ef8ce9bc69879","children":[],"id":"23978985827a92f1","title":"java.time.format.DateTimeFormat"}],"id":"3b1ef8ce9bc69879","title":"JDK8中Date类"},{"parent":"root","children":[{"parent":"01470d56d6c58a1c","children":[],"id":"20a361b79494eb16","title":"正常情况下，只能 == 或者!=&nbsp; 而不能&gt; &lt;"},{"parent":"01470d56d6c58a1c","children":[{"parent":"c1ab0b34292c1b97","children":[],"id":"ccca4a3558ab82a2","title":"对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法"}],"id":"c1ab0b34292c1b97","title":"自然排序java.lang.Comparable&nbsp; &nbsp; String、包装类等实现了Comparable接口，重写了compareTo(obj)方法"},{"parent":"01470d56d6c58a1c","children":[],"id":"0bb0bb8a082d26c6","title":"定值排序java.utils.Comparator"}],"id":"01470d56d6c58a1c","title":"Java比较器"}],"root":true,"theme":"theme3","id":"root","title":"Java常用类","structure":"mind_free"}},"meta":{"exportTime":"2021-07-25 16:50:48","member":"60ef8a5cf346fb06e6a9d554","diagramInfo":{"creator":"60ef8a5cf346fb06e6a9d554","created":"2021-07-19 10:38:22","modified":"2021-07-19 16:35:05","title":"Java常用类","category":"outline"},"id":"60f4e59e1efad41bbeaa7de2","type":"ProcessOn Schema File","version":"1.0"}}